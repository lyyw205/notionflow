import { Hono } from "hono";
import { z } from "zod";
import { db } from "@/lib/db";
import {
  pages,
  tags,
  pageTags,
  embeddings,
  categories,
  projects,
  milestones,
  reports,
  pageEntities,
  tasks,
} from "@/lib/db/schema";
import { eq, and, gte, lte, inArray } from "drizzle-orm";
import { randomUUID } from "crypto";
import { sseManager } from "../services/sse-manager";
import { triggerProjectAnalysis } from "../services/ai-trigger";
import { createSuggestion } from "../services/suggestion-service";

const app = new Hono();

const callbackSchema = z.object({
  pageId: z.string(),
  noteType: z
    .enum(["meeting_note", "todo", "decision", "idea", "reference", "log"])
    .optional(),
  tags: z.array(
    z.object({
      name: z.string(),
      score: z.number(),
    })
  ),
  summary: z.string(),
  embedding: z.array(z.number()),
  clusterId: z.number().nullable().optional(),
  entities: z
    .array(
      z.object({
        type: z.enum(["person", "date", "url", "project", "deadline"]),
        value: z.string(),
        metadata: z.record(z.unknown()).nullable().optional(),
      })
    )
    .optional()
    .default([]),
  todos: z
    .array(
      z.object({
        title: z.string(),
        priority: z.enum(["low", "medium", "high", "urgent"]).optional().default("medium"),
        dueDate: z.string().nullable().optional(),
        assignee: z.string().nullable().optional(),
      })
    )
    .optional()
    .default([]),
  confidence: z.number().optional(),
  statusSignals: z
    .array(
      z.object({
        signal: z.enum(["done", "in_progress", "blocked"]),
        keyword: z.string(),
        context: z.string(),
      })
    )
    .optional()
    .default([]),
});

app.post("/callback", async (c) => {
  const body = await c.req.json();
  const parsed = callbackSchema.safeParse(body);
  if (!parsed.success) {
    return c.json({ error: parsed.error.flatten() }, 400);
  }

  const {
    pageId,
    noteType,
    tags: tagData,
    summary,
    embedding,
    clusterId,
    entities,
    todos,
    statusSignals,
  } = parsed.data;

  // Verify page exists
  const page = db.select().from(pages).where(eq(pages.id, pageId)).get();
  if (!page) {
    return c.json({ error: "Page not found" }, 404);
  }

  const now = Math.floor(Date.now() / 1000);

  // Update page summary + noteType
  db.update(pages)
    .set({
      summary,
      ...(noteType ? { noteType } : {}),
    })
    .where(eq(pages.id, pageId))
    .run();

  // Store embedding
  const vectorBuffer = Buffer.from(new Float32Array(embedding).buffer);
  const existingEmbedding = db
    .select()
    .from(embeddings)
    .where(eq(embeddings.pageId, pageId))
    .get();

  if (existingEmbedding) {
    db.update(embeddings)
      .set({ vector: vectorBuffer, clusterId: clusterId ?? null })
      .where(eq(embeddings.pageId, pageId))
      .run();
  } else {
    db.insert(embeddings)
      .values({
        id: randomUUID(),
        pageId,
        vector: vectorBuffer,
        clusterId: clusterId ?? null,
      })
      .run();
  }

  // Handle tags: remove old auto-generated tags, insert new ones
  db.delete(pageTags)
    .where(eq(pageTags.pageId, pageId))
    .run();

  for (const t of tagData) {
    let tagRecord = db
      .select()
      .from(tags)
      .where(eq(tags.name, t.name))
      .get();

    if (!tagRecord) {
      const tagId = randomUUID();
      db.insert(tags).values({ id: tagId, name: t.name }).run();
      tagRecord = { id: tagId, name: t.name };
    }

    db.insert(pageTags)
      .values({
        id: randomUUID(),
        pageId,
        tagId: tagRecord.id,
        confidence: t.score,
        source: "auto",
      })
      .run();
  }

  // Route category change through HITL suggestion queue
  if (clusterId != null) {
    const clusterCategoryName = `Cluster ${clusterId}`;
    let category = db
      .select()
      .from(categories)
      .where(eq(categories.name, clusterCategoryName))
      .get();

    if (!category) {
      const catId = randomUUID();
      db.insert(categories)
        .values({
          id: catId,
          name: clusterCategoryName,
          description: `Auto-generated category for cluster ${clusterId}`,
          isAutoGenerated: 1,
          createdAt: now,
        })
        .run();
      category = {
        id: catId,
        name: clusterCategoryName,
        description: `Auto-generated category for cluster ${clusterId}`,
        isAutoGenerated: 1,
        createdAt: now,
      };
    }

    // Only suggest if page doesn't already have a user-set category
    if (!page.categoryId) {
      createSuggestion({
        type: "category_change",
        pageId,
        payload: {
          categoryId: category.id,
          categoryName: clusterCategoryName,
        },
        confidence: parsed.data.confidence,
      });
    }
  }

  // Phase 2: Store entities (replace old ones for this page)
  if (entities.length > 0) {
    db.delete(pageEntities)
      .where(eq(pageEntities.pageId, pageId))
      .run();

    for (const entity of entities) {
      db.insert(pageEntities)
        .values({
          id: randomUUID(),
          pageId,
          entityType: entity.type,
          value: entity.value,
          metadata: entity.metadata ? JSON.stringify(entity.metadata) : null,
          createdAt: now,
        })
        .run();
    }
  }

  // Phase 2+5: Route todo creation through HITL suggestion queue
  if (todos.length > 0) {
    for (const todo of todos) {
      createSuggestion({
        type: "task_create",
        pageId,
        payload: {
          title: todo.title,
          priority: todo.priority,
          dueDate: todo.dueDate ? parseDateToEpoch(todo.dueDate) : null,
          projectId: page.projectId,
          milestoneId: page.milestoneId,
          assignee: todo.assignee ?? null,
        },
        confidence: parsed.data.confidence,
      });
    }
  }

  // Phase 4: Status signal handling — route through HITL suggestion queue
  if (statusSignals.length > 0 && page.projectId) {
    // Find tasks linked to this page that could be updated
    const pageTasks = db
      .select()
      .from(tasks)
      .where(eq(tasks.sourcePageId, pageId))
      .all();

    for (const signal of statusSignals) {
      const statusMap: Record<string, string> = {
        done: "done",
        in_progress: "in_progress",
        blocked: "backlog",
      };
      const newStatus = statusMap[signal.signal];

      for (const task of pageTasks) {
        if (task.status !== newStatus) {
          createSuggestion({
            type: "status_update",
            pageId,
            payload: {
              taskId: task.id,
              taskTitle: task.title,
              fromStatus: task.status,
              newStatus,
              keyword: signal.keyword,
              context: signal.context,
            },
            confidence: parsed.data.confidence,
          });
        }
      }
    }
  }

  // Broadcast SSE event
  sseManager.broadcast("page-updated", {
    pageId,
    summary,
    noteType,
    tags: tagData,
    clusterId,
    entityCount: entities.length,
    todoCount: todos.length,
    statusSignalCount: statusSignals.length,
  });

  // Trigger project analysis if page belongs to a project
  const updatedPage = db.select().from(pages).where(eq(pages.id, pageId)).get();
  if (updatedPage?.projectId) {
    triggerProjectAnalysis(updatedPage.projectId);
  }

  return c.json({ success: true });
});

const projectCallbackSchema = z.object({
  projectId: z.string(),
  overallProgress: z.number(),
  aiSummary: z.string(),
  milestoneUpdates: z.array(
    z.object({
      milestoneId: z.string(),
      aiProgress: z.number(),
      aiSummary: z.string(),
    })
  ),
});

app.post("/project-callback", async (c) => {
  const body = await c.req.json();
  const parsed = projectCallbackSchema.safeParse(body);
  if (!parsed.success) {
    return c.json({ error: parsed.error.flatten() }, 400);
  }

  const { projectId, overallProgress, aiSummary, milestoneUpdates } =
    parsed.data;

  const now = Math.floor(Date.now() / 1000);

  db.update(projects)
    .set({ progress: overallProgress, aiSummary, updatedAt: now })
    .where(eq(projects.id, projectId))
    .run();

  for (const mu of milestoneUpdates) {
    db.update(milestones)
      .set({
        aiProgress: mu.aiProgress,
        aiSummary: mu.aiSummary,
        updatedAt: now,
      })
      .where(eq(milestones.id, mu.milestoneId))
      .run();
  }

  sseManager.broadcast("project-updated", { projectId });

  return c.json({ success: true });
});

// --- AI sidecar scheduler endpoints ---

const clusterResultsSchema = z.object({
  clusters: z.array(
    z.object({
      cluster_id: z.number(),
      page_ids: z.array(z.string()),
    })
  ),
  noise: z.array(z.string()),
});

const reportSchema = z.object({
  type: z.enum(["daily", "weekly"]),
  period_start: z.string(),
  period_end: z.string(),
  summary: z.string(),
  total_changes: z.number(),
  changes: z.array(
    z.object({
      title: z.string(),
      summary: z.string(),
      action: z.string(),
    })
  ),
});

// Called by recluster job (6h interval) to fetch all embeddings
app.post("/trigger-recluster", async (c) => {
  const allEmbeddings = db.select().from(embeddings).all();

  const result = allEmbeddings.map((row) => {
    const buf = Buffer.from(row.vector as ArrayBuffer);
    const floats = new Float32Array(
      buf.buffer,
      buf.byteOffset,
      buf.byteLength / 4
    );
    return {
      page_id: row.pageId,
      vector: Array.from(floats),
    };
  });

  return c.json({ embeddings: result });
});

// Called by recluster job after clustering completes
app.post("/cluster-results", async (c) => {
  const body = await c.req.json();
  const parsed = clusterResultsSchema.safeParse(body);
  if (!parsed.success) {
    return c.json({ error: parsed.error.flatten() }, 400);
  }

  const { clusters, noise } = parsed.data;

  db.transaction((tx) => {
    for (const cluster of clusters) {
      if (cluster.page_ids.length === 0) continue;

      // Update embeddings cluster assignment
      tx.update(embeddings)
        .set({ clusterId: cluster.cluster_id })
        .where(inArray(embeddings.pageId, cluster.page_ids))
        .run();

      // Find or create auto-generated category
      const clusterName = `Cluster ${cluster.cluster_id}`;
      let category = tx
        .select()
        .from(categories)
        .where(eq(categories.name, clusterName))
        .get();

      if (!category) {
        const catId = randomUUID();
        tx.insert(categories)
          .values({
            id: catId,
            name: clusterName,
            description: `Auto-generated category for cluster ${cluster.cluster_id}`,
            isAutoGenerated: 1,
            createdAt: Math.floor(Date.now() / 1000),
          })
          .run();
        category = { id: catId, name: clusterName, description: null, isAutoGenerated: 1, createdAt: 0 };
      }

      // Assign pages to category
      tx.update(pages)
        .set({ categoryId: category.id })
        .where(inArray(pages.id, cluster.page_ids))
        .run();
    }

    // Clear cluster assignment for noise pages
    if (noise.length > 0) {
      tx.update(embeddings)
        .set({ clusterId: null })
        .where(inArray(embeddings.pageId, noise))
        .run();
    }
  });

  sseManager.broadcast("cluster-updated", {
    clusterCount: clusters.length,
    noiseCount: noise.length,
  });

  return c.json({ success: true });
});

// Called by report job to fetch page changes in a period
app.get("/changes", async (c) => {
  const periodStart = c.req.query("period_start");
  const periodEnd = c.req.query("period_end");

  if (!periodStart || !periodEnd) {
    return c.json({ error: "period_start and period_end are required" }, 400);
  }

  const startEpoch = Math.floor(Date.parse(periodStart) / 1000);
  const endEpoch = Math.floor(Date.parse(periodEnd) / 1000);

  if (isNaN(startEpoch) || isNaN(endEpoch)) {
    return c.json({ error: "Invalid date format" }, 400);
  }

  const changedPages = db
    .select()
    .from(pages)
    .where(and(gte(pages.updatedAt, startEpoch), lte(pages.updatedAt, endEpoch)))
    .all();

  const changes = changedPages.map((p) => ({
    title: p.title,
    summary: p.summary ?? "",
    action: p.createdAt === p.updatedAt ? "created" as const : "updated" as const,
  }));

  return c.json({ changes });
});

// Called by report job to save a generated report
app.post("/report", async (c) => {
  const body = await c.req.json();
  const parsed = reportSchema.safeParse(body);
  if (!parsed.success) {
    return c.json({ error: parsed.error.flatten() }, 400);
  }

  const { type, period_start, period_end, summary, total_changes, changes } =
    parsed.data;

  const startEpoch = Math.floor(Date.parse(period_start) / 1000);
  const endEpoch = Math.floor(Date.parse(period_end) / 1000);

  if (isNaN(startEpoch) || isNaN(endEpoch)) {
    return c.json({ error: "Invalid date format" }, 400);
  }

  const startDate = new Date(period_start).toISOString().split("T")[0];
  const endDate = new Date(period_end).toISOString().split("T")[0];
  const title = `${type === "daily" ? "Daily" : "Weekly"} Report: ${startDate} - ${endDate}`;

  const id = randomUUID();
  const now = Math.floor(Date.now() / 1000);

  db.insert(reports)
    .values({
      id,
      type,
      title,
      content: JSON.stringify({ summary, total_changes, changes }),
      periodStart: startEpoch,
      periodEnd: endEpoch,
      createdAt: now,
    })
    .run();

  sseManager.broadcast("report-created", { reportId: id, title });

  return c.json({ success: true, reportId: id });
});

// --- Helper functions ---

function parseDateToEpoch(dateStr: string): number | null {
  // Try ISO format (YYYY-MM-DD)
  const isoMatch = dateStr.match(/(\d{4})[-/.](\d{1,2})[-/.](\d{1,2})/);
  if (isoMatch) {
    const d = new Date(
      parseInt(isoMatch[1]),
      parseInt(isoMatch[2]) - 1,
      parseInt(isoMatch[3])
    );
    return Math.floor(d.getTime() / 1000);
  }

  // Try Korean format (M월 D일) — assume current year
  const koreanMatch = dateStr.match(/(\d{1,2})월\s*(\d{1,2})일/);
  if (koreanMatch) {
    const year = new Date().getFullYear();
    const d = new Date(year, parseInt(koreanMatch[1]) - 1, parseInt(koreanMatch[2]));
    return Math.floor(d.getTime() / 1000);
  }

  // Try slash format (M/D) — assume current year
  const slashMatch = dateStr.match(/(\d{1,2})\/(\d{1,2})/);
  if (slashMatch) {
    const year = new Date().getFullYear();
    const d = new Date(year, parseInt(slashMatch[1]) - 1, parseInt(slashMatch[2]));
    return Math.floor(d.getTime() / 1000);
  }

  return null;
}

export default app;
