import { Hono } from "hono";
import { z } from "zod";
import { db } from "@/lib/db";
import {
  pages,
  tags,
  pageTags,
  embeddings,
  categories,
} from "@/lib/db/schema";
import { eq } from "drizzle-orm";
import { randomUUID } from "crypto";
import { sseManager } from "../services/sse-manager";

const app = new Hono();

const callbackSchema = z.object({
  pageId: z.string(),
  tags: z.array(
    z.object({
      name: z.string(),
      score: z.number(),
    })
  ),
  summary: z.string(),
  embedding: z.array(z.number()),
  clusterId: z.number().nullable().optional(),
});

app.post("/callback", async (c) => {
  const body = await c.req.json();
  const parsed = callbackSchema.safeParse(body);
  if (!parsed.success) {
    return c.json({ error: parsed.error.flatten() }, 400);
  }

  const { pageId, tags: tagData, summary, embedding, clusterId } = parsed.data;

  // Verify page exists
  const page = db.select().from(pages).where(eq(pages.id, pageId)).get();
  if (!page) {
    return c.json({ error: "Page not found" }, 404);
  }

  // Update page summary
  db.update(pages).set({ summary }).where(eq(pages.id, pageId)).run();

  // Store embedding
  const vectorBuffer = Buffer.from(new Float32Array(embedding).buffer);
  const existingEmbedding = db
    .select()
    .from(embeddings)
    .where(eq(embeddings.pageId, pageId))
    .get();

  if (existingEmbedding) {
    db.update(embeddings)
      .set({ vector: vectorBuffer, clusterId: clusterId ?? null })
      .where(eq(embeddings.pageId, pageId))
      .run();
  } else {
    db.insert(embeddings)
      .values({
        id: randomUUID(),
        pageId,
        vector: vectorBuffer,
        clusterId: clusterId ?? null,
      })
      .run();
  }

  // Handle tags: remove old auto-generated tags, insert new ones
  db.delete(pageTags)
    .where(eq(pageTags.pageId, pageId))
    .run();

  for (const t of tagData) {
    let tagRecord = db
      .select()
      .from(tags)
      .where(eq(tags.name, t.name))
      .get();

    if (!tagRecord) {
      const tagId = randomUUID();
      db.insert(tags).values({ id: tagId, name: t.name }).run();
      tagRecord = { id: tagId, name: t.name };
    }

    db.insert(pageTags)
      .values({
        id: randomUUID(),
        pageId,
        tagId: tagRecord.id,
        confidence: t.score,
        source: "auto",
      })
      .run();
  }

  // Update category based on cluster if provided
  if (clusterId != null) {
    const clusterCategoryName = `Cluster ${clusterId}`;
    let category = db
      .select()
      .from(categories)
      .where(eq(categories.name, clusterCategoryName))
      .get();

    if (!category) {
      const catId = randomUUID();
      db.insert(categories)
        .values({
          id: catId,
          name: clusterCategoryName,
          description: `Auto-generated category for cluster ${clusterId}`,
          isAutoGenerated: 1,
          createdAt: Math.floor(Date.now() / 1000),
        })
        .run();
      category = {
        id: catId,
        name: clusterCategoryName,
        description: `Auto-generated category for cluster ${clusterId}`,
        isAutoGenerated: 1,
        createdAt: Math.floor(Date.now() / 1000),
      };
    }

    db.update(pages)
      .set({ categoryId: category.id })
      .where(eq(pages.id, pageId))
      .run();
  }

  // Broadcast SSE event
  sseManager.broadcast("page-updated", {
    pageId,
    summary,
    tags: tagData,
    clusterId,
  });

  return c.json({ success: true });
});

export default app;
